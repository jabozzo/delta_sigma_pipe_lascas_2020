%% Generated by Sphinx.
\def\sphinxdocclass{report}
\documentclass[letterpaper,10pt,english]{sphinxmanual}
\ifdefined\pdfpxdimen
   \let\sphinxpxdimen\pdfpxdimen\else\newdimen\sphinxpxdimen
\fi \sphinxpxdimen=.75bp\relax

\PassOptionsToPackage{warn}{textcomp}
\usepackage[utf8]{inputenc}
\ifdefined\DeclareUnicodeCharacter
% support both utf8 and utf8x syntaxes
  \ifdefined\DeclareUnicodeCharacterAsOptional
    \def\sphinxDUC#1{\DeclareUnicodeCharacter{"#1}}
  \else
    \let\sphinxDUC\DeclareUnicodeCharacter
  \fi
  \sphinxDUC{00A0}{\nobreakspace}
  \sphinxDUC{2500}{\sphinxunichar{2500}}
  \sphinxDUC{2502}{\sphinxunichar{2502}}
  \sphinxDUC{2514}{\sphinxunichar{2514}}
  \sphinxDUC{251C}{\sphinxunichar{251C}}
  \sphinxDUC{2572}{\textbackslash}
\fi
\usepackage{cmap}
\usepackage[T1]{fontenc}
\usepackage{amsmath,amssymb,amstext}
\usepackage{babel}



\usepackage{times}
\expandafter\ifx\csname T@LGR\endcsname\relax
\else
% LGR was declared as font encoding
  \substitutefont{LGR}{\rmdefault}{cmr}
  \substitutefont{LGR}{\sfdefault}{cmss}
  \substitutefont{LGR}{\ttdefault}{cmtt}
\fi
\expandafter\ifx\csname T@X2\endcsname\relax
  \expandafter\ifx\csname T@T2A\endcsname\relax
  \else
  % T2A was declared as font encoding
    \substitutefont{T2A}{\rmdefault}{cmr}
    \substitutefont{T2A}{\sfdefault}{cmss}
    \substitutefont{T2A}{\ttdefault}{cmtt}
  \fi
\else
% X2 was declared as font encoding
  \substitutefont{X2}{\rmdefault}{cmr}
  \substitutefont{X2}{\sfdefault}{cmss}
  \substitutefont{X2}{\ttdefault}{cmtt}
\fi


\usepackage[Bjarne]{fncychap}
\usepackage{sphinx}

\fvset{fontsize=\small}
\usepackage{geometry}

% Include hyperref last.
\usepackage{hyperref}
% Fix anchor placement for figures with captions.
\usepackage{hypcap}% it must be loaded after hyperref.
% Set up styles of URL: it should be placed after hyperref.
\urlstyle{same}
\addto\captionsenglish{\renewcommand{\contentsname}{Contents:}}

\usepackage{sphinxmessages}
\setcounter{tocdepth}{1}



\title{calib}
\date{Aug 07, 2019}
\release{0.8}
\author{Juan Andrés Bozzo}
\newcommand{\sphinxlogo}{\vbox{}}
\renewcommand{\releasename}{Release}
\makeindex
\begin{document}

\pagestyle{empty}
\sphinxmaketitle
\pagestyle{plain}
\sphinxtableofcontents
\pagestyle{normal}
\phantomsection\label{\detokenize{index::doc}}



\chapter{\sphinxtitleref{gen} Module}
\label{\detokenize{gen:gen-module}}\label{\detokenize{gen::doc}}
This module contain classes and functions for GENerating data about
the adc and the calibration conditions

\phantomsection\label{\detokenize{gen:module-calib.gen}}\index{calib.gen (module)@\spxentry{calib.gen}\spxextra{module}}\index{PipeParameters (class in calib.gen)@\spxentry{PipeParameters}\spxextra{class in calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.PipeParameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{PipeParameters}}}{\emph{stages}, \emph{tail}}{}
This class just holds multiple stages together and the thresholds of the
final sub-ADC that converts the last stage residual.
\index{stages() (calib.gen.PipeParameters property)@\spxentry{stages()}\spxextra{calib.gen.PipeParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.PipeParameters.stages}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{stages}}}
The stages that make this adc.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{data.tuple\_of(StageParameters)}}

\end{description}\end{quote}

\end{fulllineitems}

\index{tail() (calib.gen.PipeParameters property)@\spxentry{tail()}\spxextra{calib.gen.PipeParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.PipeParameters.tail}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{tail}}}
The thresholds of the final sub-ADC that converts the last stage’s
residual.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.array}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{StageMeta (class in calib.gen)@\spxentry{StageMeta}\spxextra{class in calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{StageMeta}}}{\emph{n\_bits}, \emph{n\_refs}, \emph{eff=0.995}, \emph{cap=1}, \emph{fsr=(-0.5}, \emph{0.5)}, \emph{differential=False}, \emph{seed=None}, \emph{half\_bit=None}, \emph{data\_location=None}}{}
This class holds the metadata for a pipeline stage. The metadata is
comprised of the design constraints that generate the ADC, these are:
number of bits, number of references per capacitor and full scale range
(FSR). The rest of the metadata is either deduced from that (LSB, number
of capacitors, …) or is arbitrary (capacitor magnitude, charge transfer
efficiency, …)
\index{cap() (calib.gen.StageMeta property)@\spxentry{cap()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.cap}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{cap}}}
Ideal value of a capacitor.

\end{fulllineitems}

\index{differential() (calib.gen.StageMeta property)@\spxentry{differential()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.differential}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{differential}}}
True if the stage have a differential architecture.

\end{fulllineitems}

\index{eff() (calib.gen.StageMeta property)@\spxentry{eff()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.eff}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{eff}}}
Ideal of the charge transfer efficiency.

\end{fulllineitems}

\index{fsr() (calib.gen.StageMeta property)@\spxentry{fsr()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.fsr}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{fsr}}}
Full scale range (FSR). It’s a tuple with the minimum and maximum
voltages the stage can handle without saturation.

\end{fulllineitems}

\index{generate\_gaussian() (calib.gen.StageMeta method)@\spxentry{generate\_gaussian()}\spxextra{calib.gen.StageMeta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.generate_gaussian}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate\_gaussian}}}{\emph{s\_eff=0}, \emph{s\_cap=0}, \emph{s\_refs=0}, \emph{s\_thres=0}}{}
Instances a variation of the stage, with mostly gaussian perturbations.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s\_eff}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.array}}) \textendash{} Standard deviation of the charge transfer efficiency. The
standard deviation is expressed in time constants as explained in
{\hyperref[\detokenize{gen:calib.gen.eff_random}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{eff\_random()}}}}}.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s\_cap}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.array}}) \textendash{} Standard deviation of capacitors, in farads.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s\_refs}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.array}}) \textendash{} Standard deviation of references, in volts.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{s\_thres}} (\sphinxstyleliteralemphasis{\sphinxupquote{numpy.array}}) \textendash{} Standard deviation of sub-ADC thresholds, in volts.

\end{itemize}

\item[{Returns}] \leavevmode
An ideal stage instance based on this metadata

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{gen:calib.gen.StageParameters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StageParameters}}}}}

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.eff_random}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{eff\_random()}}}}}, for information about the random
distribution of the charge transfer efficiency parameter.



\end{fulllineitems}

\index{generate\_ideal() (calib.gen.StageMeta method)@\spxentry{generate\_ideal()}\spxextra{calib.gen.StageMeta method}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.generate_ideal}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{generate\_ideal}}}{}{}
Instances an ideal stage.
\begin{quote}\begin{description}
\item[{Returns}] \leavevmode
An ideal stage instance based on this metadata.

\item[{Return type}] \leavevmode
{\hyperref[\detokenize{gen:calib.gen.StageParameters}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StageParameters}}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{half\_bit() (calib.gen.StageMeta property)@\spxentry{half\_bit()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.half_bit}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{half\_bit}}}
Boolean indicating if the stage is half\_bit. If n\_bits is N and
half\_bit is True, then the stage is N-5 bits, otherwise is N bits.

\end{fulllineitems}

\index{lsb() (calib.gen.StageMeta property)@\spxentry{lsb()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.lsb}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{lsb}}}
Least significant bit (LSB) value, given the number of references per
capacitor, stage bits and FSR of this adc.

\end{fulllineitems}

\index{n\_bits() (calib.gen.StageMeta property)@\spxentry{n\_bits()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.n_bits}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_bits}}}
Integer number of bits of this stage.


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.StageMeta.half_bit}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{half\_bit}}}}}, for information about
half-bit stages.



\end{fulllineitems}

\index{n\_caps() (calib.gen.StageMeta property)@\spxentry{n\_caps()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.n_caps}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_caps}}}
Total number of capacitors in the stage.

\end{fulllineitems}

\index{n\_codes() (calib.gen.StageMeta property)@\spxentry{n\_codes()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.n_codes}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_codes}}}
Number of codes this stage handles (the sub-ADC and MDAC)

\end{fulllineitems}

\index{n\_refs() (calib.gen.StageMeta property)@\spxentry{n\_refs()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.n_refs}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{n\_refs}}}
Number of references each capacitor can access.

\end{fulllineitems}

\index{seed() (calib.gen.StageMeta property)@\spxentry{seed()}\spxextra{calib.gen.StageMeta property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageMeta.seed}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{seed}}}
Seed for generating random stage instances.

\end{fulllineitems}


\end{fulllineitems}

\index{StageParameters (class in calib.gen)@\spxentry{StageParameters}\spxextra{class in calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters}}\pysiglinewithargsret{\sphinxbfcode{\sphinxupquote{class }}\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{StageParameters}}}{\emph{meta}, \emph{eff}, \emph{caps}, \emph{refs}, \emph{thres}, \emph{data\_location=None}}{}
This class holds the instanced data for a stage. The interpretation of this
class is double. If interpreted as a pipeline stage, the thresholds
represent the sub-ADC of this stage. It can be also used to represent a
delta-sigma loop, with thresholds representing the sub-ADC of the next
stage or the last sub-ADC in a pipeline converter.
\index{caps() (calib.gen.StageParameters property)@\spxentry{caps()}\spxextra{calib.gen.StageParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters.caps}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{caps}}}
The capacitors value, in farads.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}

\index{caps\_ext() (calib.gen.StageParameters property)@\spxentry{caps\_ext()}\spxextra{calib.gen.StageParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters.caps_ext}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{caps\_ext}}}
The capacitors value, in farads with a last dummy capacitors of 0
farads. Useful for indexing null capacitors.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}

\index{eff() (calib.gen.StageParameters property)@\spxentry{eff()}\spxextra{calib.gen.StageParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters.eff}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{eff}}}
The charge transfer efficiency parameter.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}

\index{meta() (calib.gen.StageParameters property)@\spxentry{meta()}\spxextra{calib.gen.StageParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters.meta}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{meta}}}
The metadata of this stage.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
{\hyperref[\detokenize{gen:calib.gen.StageMeta}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{StageMeta}}}}}

\end{description}\end{quote}

\end{fulllineitems}

\index{refs() (calib.gen.StageParameters property)@\spxentry{refs()}\spxextra{calib.gen.StageParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters.refs}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{refs}}}
The references value for each capacitor, in volts.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}

\index{refs\_ext() (calib.gen.StageParameters property)@\spxentry{refs\_ext()}\spxextra{calib.gen.StageParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters.refs_ext}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{refs\_ext}}}
The references value for each capacitor, in volts, with a last dummy
reference of 0 volts, useful for indexing null references.
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}

\index{thres() (calib.gen.StageParameters property)@\spxentry{thres()}\spxextra{calib.gen.StageParameters property}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.StageParameters.thres}}\pysigline{\sphinxbfcode{\sphinxupquote{property }}\sphinxbfcode{\sphinxupquote{thres}}}
The threshold values, in volts. Depending on the interpretation, those
are associated with the stage sub-ADC (pipeline) or the next stage
sub-ADC (delta-sigma).
\begin{quote}\begin{description}
\item[{Type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}


\end{fulllineitems}

\index{adjust\_map() (in module calib.gen)@\spxentry{adjust\_map()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.adjust_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{adjust\_map}}}{\emph{map\_}, \emph{n\_codes}}{}
Expands a pipeline map to work with an sub-ADC with the same or more codes
than the original sub-ADC.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{map}} (\sphinxcode{\sphinxupquote{numpy.ndarray}}) \textendash{} The pipeline map.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_codes}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} The number of codes the sub-ADC support.

\end{itemize}

\item[{Returns}] \leavevmode
The expanded pipeline map.

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{AssertionError}} \textendash{} If the map is bigger than the target number of
codes.

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.pipe_map}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{pipe\_map()}}}}}



\end{fulllineitems}

\index{compute\_lsb() (in module calib.gen)@\spxentry{compute\_lsb()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.compute_lsb}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{compute\_lsb}}}{\emph{n\_bits}, \emph{fsr\_min}, \emph{fsr\_max}, \emph{n\_refs}, \emph{half\_bit=None}}{}
Computes the least significant bit (LSB) magnitude in the stage MDAC and
sub-ADC to achieve a desired full scale range (FSR). The input FSR and
output FSR are assumed to be the same so only one value is returned.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_bits}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bits of the stage

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fsr\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minimum value of the full voltage scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fsr\_min}} \textendash{} Maximum value of the full voltage scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_refs}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of references each active capacitor can use.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{half\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If the number of bits is half-bit or not

\end{itemize}

\item[{Returns}] \leavevmode
The voltage value of the LSB.

\item[{Return type}] \leavevmode
float

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.parse_bits}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse\_bits()}}}}}, for n\_bits and half\_bit specification.



\end{fulllineitems}

\index{compute\_n\_caps() (in module calib.gen)@\spxentry{compute\_n\_caps()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.compute_n_caps}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{compute\_n\_caps}}}{\emph{n\_bits}, \emph{n\_refs}, \emph{half\_bit=None}}{}
Computes the number of capacitors a stage needs to achieve the desired
resolution.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_bits}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bits of the stage

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_refs}} \textendash{} Number of references each active capacitor can use.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{half\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If the number of bits is half-bit or not

\end{itemize}

\item[{Returns}] \leavevmode
The number of capacitors the stage needs.

\item[{Return type}] \leavevmode
int

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{AssertionError}} \textendash{} If the number of references is invalid for the
number of bits.

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.parse_bits}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse\_bits()}}}}}, for n\_bits and half\_bit specification.



\end{fulllineitems}

\index{compute\_n\_codes() (in module calib.gen)@\spxentry{compute\_n\_codes()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.compute_n_codes}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{compute\_n\_codes}}}{\emph{n\_bits}, \emph{half\_bit=None}}{}
Computes the number of codes a pipeline stage can process.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_bits}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bits of the stage

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{half\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If the number of bits is half-bit or not

\end{itemize}

\item[{Returns}] \leavevmode
The number of codes the pipeline stage can handle

\item[{Return type}] \leavevmode
int

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.parse_bits}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse\_bits()}}}}}, for n\_bits and half\_bit specification.



\end{fulllineitems}

\index{compute\_ref() (in module calib.gen)@\spxentry{compute\_ref()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.compute_ref}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{compute\_ref}}}{\emph{n\_bits}, \emph{fsr\_min}, \emph{fsr\_max}, \emph{n\_refs}, \emph{half\_bit=None}}{}
Computes the capacitor references votage for a pipeline stage.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_bits}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bits of the stage

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fsr\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minimum value of the full voltage scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fsr\_min}} \textendash{} Maximum value of the full voltage scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_refs}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of references each active capacitor can use.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{half\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If the number of bits is half-bit or not

\end{itemize}

\item[{Returns}] \leavevmode
The values of the active capacitor references.

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.parse_bits}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse\_bits()}}}}}, for n\_bits and half\_bit specification.



\end{fulllineitems}

\index{compute\_thres() (in module calib.gen)@\spxentry{compute\_thres()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.compute_thres}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{compute\_thres}}}{\emph{n\_bits}, \emph{fsr\_min}, \emph{fsr\_max}, \emph{n\_refs}, \emph{half\_bit=None}}{}
Computes the threshold voltages for a flash sub-ADC of a pipeline stage.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_bits}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bits of the stage

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fsr\_min}} (\sphinxstyleliteralemphasis{\sphinxupquote{float}}) \textendash{} Minimum value of the full voltage scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{fsr\_min}} \textendash{} Maximum value of the full voltage scale

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_refs}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of references each active capacitor can use.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{half\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If the number of bits is half-bit or not

\end{itemize}

\item[{Returns}] \leavevmode
The values of the theshold voltages.

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.parse_bits}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse\_bits()}}}}}, for n\_bits and half\_bit specification.



\end{fulllineitems}

\index{eff\_random() (in module calib.gen)@\spxentry{eff\_random()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.eff_random}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{eff\_random}}}{\emph{eff\_mean}, \emph{tau\_std}}{}
Generates random number following a lognormal distribution, appropiate for
the charge efficiency transfer parameter (eff). The lognormal distribution
has mean in the mean parameter, but the standard deviation is computed by
proyecting the mean in logspace, generating a normal distribution with that
standard deviation and then exponeating again. This emulates the linear
settling time given by equation:
\begin{equation*}
\begin{split}\mathit{eff} = e^{\frac{-1}{2 \pi \tau}}\end{split}
\end{equation*}\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{eff\_mean}} (\sphinxcode{\sphinxupquote{numpy.ndarray}}) \textendash{} Mean of the distribution. A factor between 0 and 1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{tau\_std}} (\sphinxcode{\sphinxupquote{numpy.ndarray}}) \textendash{} Standard deviation in logspace, in time constants units.

\end{itemize}

\item[{Returns}] \leavevmode
The random numbers following the lognormal distribution. The
shape is the shape of the mutual boradcast of eff\_mean and tau\_std.

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}

\index{format\_bits() (in module calib.gen)@\spxentry{format\_bits()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.format_bits}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{format\_bits}}}{\emph{n\_bits}, \emph{half\_bit=None}}{}
Converts from int + bool representation to str representation
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_bits}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bits

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{half\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If the representation is half bit or not.

\end{itemize}

\item[{Returns}] \leavevmode
The str representation of n\_bits

\item[{Return type}] \leavevmode
str

\end{description}\end{quote}


\sphinxstrong{See also:}


{\hyperref[\detokenize{gen:calib.gen.parse_bits}]{\sphinxcrossref{\sphinxcode{\sphinxupquote{parse\_bits()}}}}}, for n\_bits and half\_bit specification.



\end{fulllineitems}

\index{parse\_bits() (in module calib.gen)@\spxentry{parse\_bits()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.parse_bits}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{parse\_bits}}}{\emph{n\_bits}, \emph{half\_bit=None}}{}
Recieves either string, float or integer representations of a number of
bits and returns the int + bool respresentation.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_bits}} (\sphinxstyleliteralemphasis{\sphinxupquote{str}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{float}}\sphinxstyleliteralemphasis{\sphinxupquote{, }}\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of bits

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{half\_bit}} (\sphinxstyleliteralemphasis{\sphinxupquote{bool}}) \textendash{} If the representation is half bit or not.

\end{itemize}

\item[{Returns}] \leavevmode
The int + bool representation of n\_bits

\item[{Return type}] \leavevmode
(int, bool,)

\item[{Raises}] \leavevmode
\sphinxstyleliteralstrong{\sphinxupquote{ValueError}} \textendash{} If the type of n\_bits is not suported or n\_bits and
half\_bit conflict with each other (eg: “2.5” and False)

\end{description}\end{quote}

\end{fulllineitems}

\index{pipe\_map() (in module calib.gen)@\spxentry{pipe\_map()}\spxextra{in module calib.gen}}

\begin{fulllineitems}
\phantomsection\label{\detokenize{gen:calib.gen.pipe_map}}\pysiglinewithargsret{\sphinxcode{\sphinxupquote{calib.gen.}}\sphinxbfcode{\sphinxupquote{pipe\_map}}}{\emph{n\_caps}, \emph{n\_refs}}{}
Creates the code-\textgreater{}reference map for pipeline operation. Each column in this
map contains the reference index to be used for the active capacitors.
\begin{quote}\begin{description}
\item[{Parameters}] \leavevmode\begin{itemize}
\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_caps}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of capacitors with active references,
usually the number of stage capacitors -1.

\item {} 
\sphinxstyleliteralstrong{\sphinxupquote{n\_refs}} (\sphinxstyleliteralemphasis{\sphinxupquote{int}}) \textendash{} Number of references per capacitor.

\end{itemize}

\item[{Returns}] \leavevmode
The map with shape \sphinxcode{\sphinxupquote{(n\_caps, n\_codes,)}}

\item[{Return type}] \leavevmode
\sphinxcode{\sphinxupquote{numpy.ndarray}}

\end{description}\end{quote}

\end{fulllineitems}



\chapter{Indices and tables}
\label{\detokenize{index:indices-and-tables}}\begin{itemize}
\item {} 
\DUrole{xref,std,std-ref}{genindex}

\item {} 
\DUrole{xref,std,std-ref}{modindex}

\item {} 
\DUrole{xref,std,std-ref}{search}

\end{itemize}


\renewcommand{\indexname}{Python Module Index}
\begin{sphinxtheindex}
\let\bigletter\sphinxstyleindexlettergroup
\bigletter{c}
\item\relax\sphinxstyleindexentry{calib.gen}\sphinxstyleindexpageref{gen:\detokenize{module-calib.gen}}
\end{sphinxtheindex}

\renewcommand{\indexname}{Index}
\printindex
\end{document}